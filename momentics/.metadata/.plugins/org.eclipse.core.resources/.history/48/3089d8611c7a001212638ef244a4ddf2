#ifdef __OPENAL__

//
//  UntzSystem.cpp
//  Part of UNTZ
//
//  Created by Francisco Tufr√≥. (francisco@ziplinegames.com) on 02/18/2013.
//  Copyright (c) 2010-2011 Zipline Games, Inc. All Rights Reserved.
//

#include "UntzSystem.h"
#include "SystemData.h"
#include "AudioMixer.h"

#include <stdio.h>
#include <string.h>

#include <AL/al.h>

using namespace UNTZ;


//int RtInOut( void* outputBuffer, void* inputBuffer, unsigned int framesPerBuffer,
//			double streamTime, RtAudioStreamStatus status, void *userdata )
//{
//	if(!UNTZ::System::get()->getData()->isActive())
//	{
//		memset(outputBuffer, 0, sizeof(float) * framesPerBuffer * UNTZ::System::get()->getData()->getNumOutputChannels());
//		return 0;
//	}
//
//	if(status)
//		std::cout << "Stream underflow detected!" << std::endl;
//	AudioMixer *mixer = (AudioMixer*)userdata;
//	mixer->process(0, NULL, UNTZ::System::get()->getData()->getNumOutputChannels(), (float*)outputBuffer, framesPerBuffer);
//
//    // volume & clipping
//    // HBS
//    UInt32 samples = UNTZ::System::get()->getData()->getNumOutputChannels() * framesPerBuffer;
//	float volume = mixer->getVolume();
//    // TODO: doing an extra read/write here is painful...
//    float *outB = (float*)outputBuffer;
//    for(UInt32 k = 0; k < samples; ++k)
//    {
//        float val = *outB * volume;
//        val = val > 1.0 ? 1.0 : val;
//        val = val < -1.0 ? -1.0 : val;
//        *(outB)++ = val;
//    }
//
//	return 0;
//}

class ALSystemData : public UNTZ::SystemData
{
public:
    ALSystemData() : SystemData() {}
    ~ALSystemData() {}
    UInt32 getNumFrames();
    UInt32 getNumOutputChannels();

    UInt32 mSampleRate;
    UInt32 mFramesPerBuffer;
    UInt32 mOptions;
};


UInt32 ALSystemData::getNumFrames()
{
	return 8192;//4096;
}
UInt32 ALSystemData::getNumOutputChannels()
{
    return 2;
}

//System* System::msInstance = 0;
//
System::System(UInt32 sampleRate, UInt32 numFrames, UInt32 options)
{
	ALSystemData *alsd = new ALSystemData();
	alsd->mSampleRate = sampleRate;
	alsd->mOptions = options;
	mpData = wsd;

	RtAudio::StreamParameters outParams;
	outParams.nChannels = 2;
	outParams.deviceId = wsd->audioIO.getDefaultOutputDevice();
	RtAudio::StreamOptions streamOptions;
	streamOptions.flags = 0 | RTAUDIO_MINIMIZE_LATENCY | RTAUDIO_NONINTERLEAVED;
	try
	{
		wsd->audioIO.openStream( &outParams, NULL, RTAUDIO_FLOAT32, sampleRate, &numFrames, &RtInOut, (void *)&mpData->mMixer, &streamOptions );
		wsd->audioIO.startStream();
	}
	catch(RtError& error)
	{
		wsd->setError(true);
		printf("!!!AudioIO Error: %s\n", error.getMessage());
	}
}
//
//System::~System()
//{
//	if(mpData)
//		delete mpData;
//}
//
//void System::shutdown()
//{
//	if(msInstance)
//	{
//		delete msInstance;
//		msInstance = 0;
//	}
//}
//
//System* System::initialize(UInt32 sampleRate, UInt32 numFrames, UInt32 options)
//{
//	if(!msInstance)
//	{
//		msInstance = new System(sampleRate, numFrames, options);
//		if(msInstance->mpData->getError())
//		{
//			delete msInstance;
//		}
//		else
//		{
//			msInstance->mpData->mMixer.init();
//		}
//	}
//
//	return msInstance;
//}
//
//System* System::get()
//{
//	return msInstance;
//}
//
//void System::setSampleRate(UInt32 sampleRate)
//{
//}
//
//unsigned int System::getSampleRate()
//{
//	WinSystemData* wsd = (WinSystemData*)mpData;
//	return wsd->audioIO.getStreamSampleRate();
//}
//
//void System::setVolume(float volume)
//{
//	return msInstance->mpData->mMixer.setVolume(volume);
//}
//
//float System::getVolume() const
//{
//	return msInstance->mpData->mMixer.getVolume();
//}
//
//void System::suspend()
//{
//	msInstance->mpData->setActive(false);
//}
//
//void System::resume()
//{
//	msInstance->mpData->setActive(true);
//}

#endif
